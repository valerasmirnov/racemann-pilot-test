<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>RaceMann Pilot — RN табло</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body { margin:0; font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif; background:#07080c; color:#eef0f4; }

    .wrap { max-width: 980px; margin: 0 auto; padding: 14px; padding-bottom: 24px; }
    .card { border:1px solid #262b35; border-radius:18px; padding:12px; background:#10131a; margin-top:12px; }
    h1 { font-size:16px; margin:0; font-weight:900; letter-spacing:-0.02em; }
    .muted { color:#9aa3ad; font-size:13px; line-height:1.35; }

    label { display:block; font-weight:900; margin-bottom:6px; font-size:12px; color:#cdd3dc; }
    input, button, select {
      font-size:16px; padding:12px 12px;
      border-radius:14px; border:1px solid #262b35;
      background:#0b0e14; color:#eef0f4; width:100%;
    }
    input::placeholder { color:#6f7782; }
    button { cursor:pointer; font-weight:900; background:#1f6feb; border-color:#1f6feb; }
    button.secondary { background:#0b0e14; border-color:#262b35; }
    button:disabled { opacity:.6; cursor:not-allowed; }

    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:end; }
    .row > * { flex: 1 1 260px; }
    .smallnote { margin-top:8px; color:#9aa3ad; font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid #262b35; color:#9aa3ad; font-size:12px; background:#0b0e14; }
    .dot { width:10px; height:10px; border-radius:999px; background:#666; display:inline-block; }
    .dot.ok { background:#26a269; }
    .dot.bad { background:#d13212; }

    .pilot { min-height:100svh; padding:14px; padding-bottom:18px; display:flex; flex-direction:column; gap:12px; }
    .pilotTopBar { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .pilotTitle { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .pilotTitle b { font-size:13px; color:#cdd3dc; }
    .pilotMeta { color:#9aa3ad; font-size:12px; }

    .board { flex:1; display:flex; flex-direction:column; gap:12px; }

    .tile { border:1px solid #262b35; border-radius:22px; background:#0b0e14; padding:14px; }
    .tile .t { color:#9aa3ad; font-size:12px; font-weight:900; letter-spacing:.02em; }
    .tile .v { font-weight:1000; letter-spacing:-0.03em; margin-top:6px; line-height:1; transform-origin:50% 65%; will-change:transform,filter,opacity; }

    .bigRow { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    .tile.big .v { font-size:72px; }

    .smallRow { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    .tile.small .v { font-size:46px; }

    .green { color:#26a269; }
    .purple { color:#bb6bff; }

    @keyframes pop { 0%{transform:scale(1);filter:brightness(1);opacity:1;} 30%{transform:scale(1.06);filter:brightness(1.25);opacity:1;} 100%{transform:scale(1);filter:brightness(1);opacity:1;} }
    .pop { animation: pop 240ms ease-out; }

    .btnRow { display:flex; gap:10px; flex-wrap:wrap; }
    .btnRow button { width:auto; padding:10px 12px; }

    .hidden { display:none !important; }

    .log { margin-top:10px; font-size:12px; color:#cdd3dc; line-height:1.35; white-space:pre-wrap; word-break:break-word; max-height:210px; overflow:auto; background:#0b0e14; border:1px solid #262b35; border-radius:14px; padding:10px; }
  </style>
</head>
<body>

  <!-- ===== SETUP ===== -->
  <div id="setupScreen" class="wrap">
    <div class="card">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
        <h1>RaceMann Pilot — RN табло</h1>
        <span class="pill"><span id="dotSetup" class="dot bad"></span><b id="statusSetup">idle</b></span>
      </div>

      <div class="muted" style="margin-top:8px">
        Выбери картодром, укажи RN, нажми <b>Открыть экран пилота</b>.
        <br/>Автосмена заезда включена: если сменится “last”, мы переподключимся сами.
      </div>

      <div class="row" style="margin-top:12px">
        <div style="flex: 3 1 420px;">
          <label>Картодром</label>
          <select id="trackSelect">
            <option value="miks" selected>MIKS Karting</option>
            <option value="lonato">Lonato</option>
            <option value="dozari">Dozari</option>
            <option value="custom">Другое (вставить ссылку)</option>
          </select>

          <div style="margin-top:10px">
            <label>Домен / ссылка</label>
            <input id="raceInput" placeholder="https://miks.racemann.com" />
            <div class="smallnote">Для стандартных картодромов заполняется автоматически</div>
          </div>
        </div>

        <div style="flex: 1 1 180px;">
          <label>RN</label>
          <input id="rn" inputmode="numeric" placeholder="например 11" />
        </div>

        <div style="flex: 1 1 260px;">
          <label>&nbsp;</label>
          <button id="btnOpen">Открыть экран пилота</button>
        </div>
      </div>

      <div class="smallnote" style="margin-top:12px">
        Worker: <span class="mono" id="workerLabel">—</span>
      </div>

      <div id="setupLog" class="log">log…</div>
    </div>
  </div>

  <!-- ===== PILOT SCREEN ===== -->
  <div id="pilotScreen" class="pilot hidden">
    <div class="pilotTopBar">
      <div class="pilotTitle">
        <span class="pill"><span id="dotPilot" class="dot bad"></span><b id="statusPilot">disconnected</b></span>
        <div>
          <div><b>RN:</b> <span id="rnShow">—</span></div>
          <div class="pilotMeta" id="metaLine">—</div>
        </div>
      </div>

      <div class="btnRow">
        <button id="btnReload" class="secondary" disabled>RELOAD</button>
        <button id="btnBack" class="secondary">Назад</button>
        <button id="btnDisconnect" class="secondary" disabled>Disconnect</button>
      </div>
    </div>

    <div class="board">
      <div class="bigRow">
        <div class="tile big">
          <div class="t">Позиция</div>
          <div id="kPos" class="v">—</div>
        </div>

        <div class="tile big">
          <div class="t">Последний круг</div>
          <div id="kLast" class="v">—</div>
        </div>
      </div>

      <div class="smallRow">
        <div class="tile small">
          <div class="t">Лучший круг пилота</div>
          <div id="kBestPilot" class="v green">—</div>
        </div>

        <div class="tile small">
          <div class="t">Лучший круг заезда</div>
          <div id="kBestRace" class="v purple">—</div>
        </div>
      </div>
    </div>

    <div id="pilotLog" class="log">log…</div>
  </div>

<script>
(() => {
  const qs = new URLSearchParams(location.search);
  const WORKER_HOST = (qs.get("worker") || "racemann-bridge-test.vsmirnoff.workers.dev").trim();

  const AUTO_RESOLVE_INTERVAL_MS = 12000;

  const TRACKS = {
    miks:   "https://miks.racemann.com",
    lonato: "https://lonato.racemann.com",
    dozari: "https://dozari.racemann.com",
  };

  const LS_TRACK = "rm_pilot_track";
  const LS_INP = "rm_pilot_input";
  const LS_RN  = "rm_pilot_rn";

  const $ = (id) => document.getElementById(id);

  let ws = null;

  let currentOrigin = null;
  let currentRaceId = null;
  let currentRaceUrl = null;

  let autoTimer = null;
  let autoResolving = false;

  const state = {
    byRn: new Map(),
    bestRaceMs: null,
    bestRaceRn: null,
    lastFrameAt: null,
    frames: 0,
    compCount: 0,
  };

  function log(where, ...args) {
    const el = where === "setup" ? $("setupLog") : $("pilotLog");
    const s = args.map(a => (typeof a === "string" ? a : JSON.stringify(a, null, 2))).join(" ");
    const line = `[${new Date().toLocaleTimeString()}] ${s}`;
    el.textContent = (el.textContent ? el.textContent + "\n" : "") + line;
    el.scrollTop = el.scrollHeight;
    console.log(line);
  }

  let wakeLock = null;
  async function enableWakeLock() {
    try {
      if (!("wakeLock" in navigator)) return false;
      wakeLock = await navigator.wakeLock.request("screen");
      return true;
    } catch { return false; }
  }
  async function disableWakeLock() {
    try { await wakeLock?.release?.(); } catch {}
    wakeLock = null;
  }

  function setDot(where, ok) {
    const dot = where === "setup" ? $("dotSetup") : $("dotPilot");
    dot.classList.toggle("ok", !!ok);
    dot.classList.toggle("bad", !ok);
  }
  function setStatus(where, text, ok) {
    (where === "setup" ? $("statusSetup") : $("statusPilot")).textContent = text;
    setDot(where, ok);
  }

  function safeJsonParse(s) {
    if (typeof s !== "string") return null;
    const t = s.trim();
    if (!t) return null;
    if (!(t.startsWith("{") || t.startsWith("["))) return null;
    try { return JSON.parse(t); } catch { return null; }
  }

  function msToLap(ms) {
    if (ms == null) return "—";
    const n = Number(ms);
    if (!Number.isFinite(n) || n <= 0) return "—";
    const totalMs = Math.round(n);
    const sec = Math.floor(totalMs / 1000);
    const msPart = String(totalMs % 1000).padStart(3, "0");
    const min = Math.floor(sec / 60);
    const secPart = String(sec % 60).padStart(2, "0");
    return `${min}:${secPart}.${msPart}`;
  }

  function extractRaceHubNewCommands(workerFrame) {
    const out = [];
    const arr = Array.isArray(workerFrame?.M) ? workerFrame.M : [];
    for (const msg of arr) {
      if (!msg) continue;
      if (msg.H !== "RaceHub") continue;
      if (msg.M !== "newCommand") continue;
      const a0 = msg.A?.[0];
      if (a0) out.push(a0);
    }
    return out;
  }

  function handleComp(cmd) {
    if ((cmd?.Method || "").toLowerCase() !== "comp") return;
    const c = cmd.Command;
    if (!c || typeof c !== "object") return;

    const rn = String(c.rn ?? c.RN ?? "").trim();
    if (!rn) return;

    const prev = state.byRn.get(rn) || {};
    const bestLapMs = Number.isFinite(+c.bl) ? +c.bl : (prev.bestLapMs ?? null);

    const next = {
      rn,
      position: Number.isFinite(+c.pos) ? +c.pos : (prev.position ?? null),
      lastLapMs: Number.isFinite(+c.ll) ? +c.ll : (prev.lastLapMs ?? null),
      bestLapMs,
      updatedAt: Date.now(),
    };

    state.byRn.set(rn, next);

    if (Number.isFinite(+bestLapMs) && +bestLapMs > 0) {
      if (state.bestRaceMs == null || +bestLapMs < state.bestRaceMs) {
        state.bestRaceMs = +bestLapMs;
        state.bestRaceRn = rn;
      }
    }
  }

  function buildWorkerWsUrl(raceUrlRaw) {
    const cleaned = raceUrlRaw.trim();
    if (!cleaned) throw new Error("raceUrl empty");
    const encoded = encodeURIComponent(cleaned);
    return `wss://${WORKER_HOST}/ws?raceUrl=${encoded}&dropHb=1`;
  }

  async function resolveRaceUrlFromOrigin(origin) {
    const url = `https://${WORKER_HOST}/resolve?origin=${encodeURIComponent(origin)}`;
    const r = await fetch(url, { cache: "no-store" });
    const j = await r.json().catch(() => ({}));
    if (!r.ok || !j.ok) throw new Error(j.error || `resolve failed (${r.status})`);
    return j;
  }

  function setValue(id, nextText) {
    const el = $(id);
    const prev = el.textContent;
    if (prev === nextText) return;
    el.textContent = nextText;
    el.classList.remove("pop");
    void el.offsetWidth;
    el.classList.add("pop");
  }

  function renderPilot() {
    const rn = String($("rn").value.trim());
    $("rnShow").textContent = rn || "—";

    const p = rn ? state.byRn.get(rn) : null;

    setValue("kPos", String(p?.position ?? "—"));
    setValue("kLast", p ? msToLap(p.lastLapMs) : "—");
    setValue("kBestPilot", p ? msToLap(p.bestLapMs) : "—");
    setValue("kBestRace", msToLap(state.bestRaceMs));

    const bestPilotMs = (p && Number.isFinite(+p.bestLapMs)) ? +p.bestLapMs : null;
    const bestRaceMs = (state.bestRaceMs != null && Number.isFinite(+state.bestRaceMs)) ? +state.bestRaceMs : null;
    const isPilotOverallBest = (bestPilotMs != null && bestRaceMs != null && bestPilotMs === bestRaceMs);

    const bestPilotEl = $("kBestPilot");
    bestPilotEl.classList.toggle("purple", isPilotOverallBest);
    bestPilotEl.classList.toggle("green", !isPilotOverallBest);

    const frames = state.frames;
    const comp = state.compCount;
    const last = state.lastFrameAt ? new Date(state.lastFrameAt).toLocaleTimeString() : "—";
    const rid = currentRaceId ? currentRaceId.slice(0, 8) : "—";
    $("metaLine").textContent = `Track: ${currentOrigin?.replace("https://","") || "—"} • Race: ${rid} • Frames: ${frames} • comp: ${comp} • last: ${last}`;
  }

  function showSetup() {
    $("pilotScreen").classList.add("hidden");
    $("setupScreen").classList.remove("hidden");
    setStatus("setup", "idle", false);
  }

  function showPilot() {
    $("setupScreen").classList.add("hidden");
    $("pilotScreen").classList.remove("hidden");
  }

  function resetRaceState() {
    state.frames = 0;
    state.compCount = 0;
    state.lastFrameAt = null;
    state.bestRaceMs = null;
    state.bestRaceRn = null;
    state.byRn.clear();
    renderPilot();
  }

  function stopAutoSwitch() {
    if (autoTimer) clearInterval(autoTimer);
    autoTimer = null;
    autoResolving = false;
  }

  function startAutoSwitch() {
    stopAutoSwitch();
    if (!currentOrigin) return;

    autoTimer = setInterval(async () => {
      if (!currentOrigin || !currentRaceId) return;
      if (autoResolving) return;

      autoResolving = true;
      try {
        const j = await resolveRaceUrlFromOrigin(currentOrigin);
        if (j.raceId && j.raceId !== currentRaceId) {
          log("pilot", "AUTO: race changed!", { from: currentRaceId, to: j.raceId });
          await reconnectToNewRace(j.raceUrl, j.raceId);
        }
      } catch (e) {
        log("pilot", "AUTO: resolve failed:", String(e?.message || e));
      } finally {
        autoResolving = false;
      }
    }, AUTO_RESOLVE_INTERVAL_MS);

    log("pilot", `AUTO: enabled (${Math.round(AUTO_RESOLVE_INTERVAL_MS/1000)}s) for ${currentOrigin}`);
  }

  async function reconnectToNewRace(newRaceUrl, newRaceId) {
    currentRaceUrl = newRaceUrl;
    currentRaceId = newRaceId;

    resetRaceState();
    await disconnect(false);
    await connectWsOnly(newRaceUrl);
    startAutoSwitch();
  }

  async function connectWsOnly(raceUrl) {
    $("btnReload").disabled = false;

    let wsUrl;
    try { wsUrl = buildWorkerWsUrl(raceUrl); }
    catch (e) {
      log("pilot", "WS url build error:", String(e));
      setStatus("pilot", "ws url error", false);
      return;
    }

    showPilot();
    setStatus("pilot", "connecting…", false);
    log("pilot", "Connecting WS:", wsUrl);

    try { ws = new WebSocket(wsUrl); }
    catch (e) {
      log("pilot", "WebSocket ctor error:", String(e));
      setStatus("pilot", "ws ctor error", false);
      return;
    }

    $("btnDisconnect").disabled = false;

    ws.addEventListener("open", async () => {
      setStatus("pilot", "connected", true);
      log("pilot", "WS open");
      await enableWakeLock();
      renderPilot();
    });

    ws.addEventListener("close", async (e) => {
      const hint = (e.code === 1006) ? " — жми RELOAD" : "";
      setStatus("pilot", `closed (${e.code})${hint}`, false);
      log("pilot", "WS closed:", { code: e.code, reason: e.reason });
      $("btnDisconnect").disabled = true;
      ws = null;
      await disableWakeLock();
    });

    ws.addEventListener("error", (e) => {
      setStatus("pilot", "error", false);
      log("pilot", "WS error:", String(e?.message || e));
    });

    ws.addEventListener("message", (evt) => {
      const text = typeof evt.data === "string" ? evt.data : "";
      const msg = safeJsonParse(text);
      if (!msg) return;

      if (msg.type && msg.type !== "frame") {
        log("pilot", "Status:", msg);
        return;
      }

      if (msg.type === "frame") {
        state.frames += 1;
        state.lastFrameAt = Date.now();

        const cmds = extractRaceHubNewCommands(msg);
        for (const cmd of cmds) {
          if ((cmd?.Method || "").toLowerCase() === "comp") {
            state.compCount += 1;
            handleComp(cmd);
          }
        }
        renderPilot();
      }
    });
  }

  async function connect() {
    const rn = $("rn").value.trim();
    if (!rn) { alert("Введи RN"); return; }

    const track = $("trackSelect").value;
    const input = track === "custom" ? $("raceInput").value.trim() : (TRACKS[track] || TRACKS.miks);
    if (!input) { alert("Выбери картодром или введи ссылку"); return; }

    $("setupLog").textContent = "";
    $("pilotLog").textContent = "";
    log("setup", "WORKER_HOST =", WORKER_HOST);
    log("setup", "Track =", track);
    log("setup", "Input =", input);

    try {
      const u = new URL(input.startsWith("http") ? input : ("https://" + input));
      currentOrigin = u.origin;
    } catch {
      alert("Некорректный домен/ссылка"); return;
    }

    setStatus("setup", "resolving…", false);

    let j;
    try {
      j = await resolveRaceUrlFromOrigin(currentOrigin);
    } catch (e) {
      setStatus("setup", "resolve failed", false);
      log("setup", "Resolve failed:", String(e?.message || e));
      alert("Не удалось определить текущий заезд: " + (e?.message || e));
      return;
    }

    currentRaceId = j.raceId;
    currentRaceUrl = j.raceUrl;

    log("setup", "Resolved:", { currentOrigin, currentRaceId, currentRaceUrl });
    setStatus("setup", "resolved", true);

    try {
      localStorage.setItem(LS_RN, rn);
      localStorage.setItem(LS_INP, input);
      localStorage.setItem(LS_TRACK, track);
    } catch {}

    resetRaceState();
    await disconnect(false);
    await connectWsOnly(currentRaceUrl);
    startAutoSwitch();
  }

  async function disconnect(goToSetup = true) {
    stopAutoSwitch();

    if (ws) {
      try { ws.close(1000, "bye"); } catch {}
      ws = null;
    }
    $("btnDisconnect").disabled = true;
    await disableWakeLock();
    setStatus("pilot", "disconnected", false);

    if (goToSetup) {
      currentOrigin = null;
      currentRaceId = null;
      currentRaceUrl = null;
      $("btnReload").disabled = true;
      showSetup();
    } else {
      showPilot();
    }
  }

  async function reloadNow() {
    if (!currentRaceUrl) return;
    log("pilot", "RELOAD: reconnect to currentRaceUrl");
    resetRaceState();
    await disconnect(false);
    await connectWsOnly(currentRaceUrl);
    startAutoSwitch();
  }

  const trackSelect = $("trackSelect");
  const raceInput = $("raceInput");

  function applyTrackSelection() {
    const v = trackSelect.value;
    if (v === "custom") {
      raceInput.disabled = false;
      raceInput.placeholder = "Вставь ссылку RaceMann";
    } else {
      raceInput.disabled = true;
      raceInput.value = TRACKS[v] || TRACKS.miks;
    }
  }

  $("btnOpen").addEventListener("click", connect);
  $("btnDisconnect").addEventListener("click", () => disconnect(true));
  $("btnBack").addEventListener("click", () => disconnect(true));
  $("btnReload").addEventListener("click", reloadNow);
  $("rn").addEventListener("input", renderPilot);

  $("workerLabel").textContent = WORKER_HOST;

  try {
    const savedRn = localStorage.getItem(LS_RN);
    if (savedRn) $("rn").value = savedRn;
  } catch {}

  try {
    const savedTrack = localStorage.getItem(LS_TRACK);
    if (savedTrack && (savedTrack in TRACKS || savedTrack === "custom")) trackSelect.value = savedTrack;
  } catch {}

  applyTrackSelection();

  try {
    const savedInp = localStorage.getItem(LS_INP);
    if (savedInp && trackSelect.value === "custom") {
      raceInput.value = savedInp;
      raceInput.disabled = false;
    }
  } catch {}

  trackSelect.addEventListener("change", () => {
    try { localStorage.setItem(LS_TRACK, trackSelect.value); } catch {}
    applyTrackSelection();
  });

  $("setupLog").textContent = "";
  log("setup", "Ready. Worker =", WORKER_HOST);
  showSetup();

  document.addEventListener("visibilitychange", async () => {
    if (document.visibilityState === "visible" && ws) await enableWakeLock();
  });
})();
</script>
</body>
</html>
